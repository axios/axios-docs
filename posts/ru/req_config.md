---
title: 'Конфигурация запроса'
prev_title: 'Экземпляр Axios'
prev_link: '/docs/instance'
next_title: 'Схема ответа'
next_link: '/docs/res_schema'
---


Это доступные параметры конфигурации для запросов. Нужен только `url`. Выполняется `GET`-запрос, если метод не указан.

```js
{
  // `url` - URL-адрес сервера, который будет использоваться для запроса
  url: '/user',

  // `method` - это метод запроса, который следует использовать при подаче запроса
  method: 'get', // значение по умолчанию

  // `baseURL` будет добавляться `url`, если `url` не является абсолютным.
  // Может быть удобно установить `baseURL` для экземпляра axios для передачи относительных URL-адресов
  // к методам этого экземпляра.
  baseURL: 'https://some-domain.com/api',

  // `transformRequest`позволяет изменять данные запроса перед его отправкой на сервер
  // Это применимо только для методов запроса 'PUT', 'POST', 'PATCH' и 'DELETE'
  // Последняя функция в массиве должна возвращать строку или экземпляр Buffer, ArrayBuffer, 
  // FormData или Stream
  // Вы можете изменить объект headers
  transformRequest: [function (data, headers) {
    // Делайте все, что хотите, чтобы преобразовать данные

    return data;
  }],

  // `transformResponse` позволяет вносить изменения в данные ответа перед их передачей then/catch
  transformResponse: [function (data) {
    // Делайте все, что хотите, чтобы преобразовать данные

    return data;
  }],

  // `headers` - это пользовательские заголовки для запроса
  headers: {'X-Requested-With': 'XMLHttpRequest'},

  // `params` - это URL-параметры, которые отправляются вместе с запросом
  // Должно быть обычным объектом или объектом URLSearchParams
  // Примечание: параметры, которые являются нулевыми или неопределенными, не отображаются в URL-адресе.
  params: {
    ID: 12345
  },

  // `paramsSerializer` — это дополнительная конфигурация, которая позволяет вам настроить сериализацию `params`.
  paramsSerializer: {

    //Пользовательская функция кодировщика, которая итеративно отправляет пары ключ/значение.
    encode?: (param: string): string => 
    { /* Выполняйте здесь пользовательские операции и возвращайте преобразованную строку. */ }, 
    
    // Пользовательская функция сериализации для всего параметра. Позволяет пользователю имитировать поведение до версии 1.x.
    serialize?: (params: Record<string, any>, options?: ParamsSerializerOptions ), 
    
    //Конфигурация форматирования индексов массива в параметрах.
    indexes: false // Три доступных варианта:
    // (1) indexes: null (приводит к отсутствию скобок), 
    // (2) (default) indexes: false (приводит к пустым скобкам),
    // (3) indexes: true (приводит к скобкам с индексами).    
  },

  // `data` - это данные, которые посылаются как тело запроса
  // Применяется только к методам запроса 'PUT', 'POST', 'DELETE , and 'PATCH'
  // Если параметр `transformRequest` не установлен, он должен иметь один из следующих типов:
  // - строка, обычный объект, ArrayBuffer, ArrayBufferView, URLSearchParams
  // - Только для браузера: FormData, File, Blob
  // - Только для Node.js: Stream, Buffer
  data: {
    firstName: 'Fred'
  },
  
  // альтернатива синтаксису для передачи данных в тело
  // POST-метода
  // отправляется только значение, а не ключ
  data: 'Country=Brasil&City=Belo Horizonte',

  // `timeout` указывает количество миллисекунд до истечения времени ожидания запроса.
  // Если запрос занимает больше времени, чем `timeout`, запрос будет прерван.
  timeout: 1000, // по умолчанию `0` (без времени ожидания)

  // `withCredentials` указывает, будут ли межсайтовые запросы управления доступом
  // должно быть сделано с использованием учетных данных
  withCredentials: false, // по умолчанию

  // `adapter`позволяет настраивать обработку запросов, что упрощает тестирование.
  // Возвращает Promise и предоставляет действительный ответ (см. lib/adapters/README.md).
  adapter: function (config) {
    /* ... */
  },

  // `auth` указывает, что следует использовать базовую аутентификацию HTTP, и предоставляет учетные данные.
  // Это установит заголовок `Authorization`, перезаписав любой существующий
  // `Authorization` пользовательский заголовок, которыё вы установили с помощью `headers`.
  // Обратите внимание, что с помощью этого параметра можно настроить только базовую аутентификацию HTTP.
  // Для токенов Bearer и т. д. вместо этого используйте пользовательский заголовок `Authorization`.
  auth: {
    username: 'janedoe',
    password: 's00pers3cret'
  },

  // `responseType` указывает тип данных, на которые будет отвечать сервер
  // типы данных: 'arraybuffer', 'document', 'json', 'text', 'stream'
  //  Только для браузера: 'blob'
  responseType: 'json', // по умолчанию

  // `responseEncoding` указывает кодирование для декодирования ответов (только для Node.js)
  // Примечание: Игнорируется для `responseType` запросов 'stream' или запросов на стороне клиента
  responseEncoding: 'utf8', // по умолчанию

  // `xsrfCookieName` - это имя файла cookie, которое будет использоваться как значение токена xsrf
  xsrfCookieName: 'XSRF-TOKEN', // по умолчанию

  // `xsrfHeaderName` - это название заголовка http, содержащее значение токена xsrf
  xsrfHeaderName: 'X-XSRF-TOKEN', // по умолчанию

  // `onUploadProgress` позволяет обрабатывать события прогресса загрузки
  // только для браузера
  onUploadProgress: function (progressEvent) {
    // Делайте все, что хотите, с родным событием прогресса
  },

  // `onDownloadProgress` позволяет обрабатывать события прогресса скачивания
  // только для браузера
  onDownloadProgress: function (progressEvent) {
    // Делайте все, что хотите, с родным событием прогресса
  },

  // `maxContentLength` определяет максимальный размер содержимого ответа http в байтах, разрешенный в node.js
  maxContentLength: 2000,

  // `maxBodyLength` (Только для Node.js) определяет максимальный разрешенный размер содержимого HTTP-запроса в байтах.
  maxBodyLength: 2000,

  // `validateStatus` определяет, разрешить или отклонить Promise для данного
  // статуса HTTP-запроса. Если `validateStatus` возвращает `true` (или установлено значение `null`
  // или `undefined`), Promise будет возвращен; иначе, Promise будет отклонен.
  validateStatus: function (status) {
    return status >= 200 && status < 300; // по умолчанию
  },

  // `maxRedirects` определяет максимальное количество перенаправлений в node.js.
  // Если установлено значение 0, перенаправления не будут выполняться.
  maxRedirects: 5, // по умолчанию

  // `socketPath` определяет UNIX Сокет для использования в node.js.
  // например '/var/run/docker.sock' для отправки запросов к docker.
  // Можно указать только `socketPath` или `proxy`.
  // Если указаны оба, используется `socketPath`.
  socketPath: null, // по умолчанию

  // `httpAgent` и `httpsAgent` определяют пользовательский агент, который будет использоваться при выполнении http
  // и https запросов, соответственно в node.js.Это позволяет добавлять такие параметры, как
  // `keepAlive` который не включен по умолчанию.
  httpAgent: new http.Agent({ keepAlive: true }),
  httpsAgent: new https.Agent({ keepAlive: true }),

  // `proxy` определяет имя хоста, порт и протокол прокси-сервера.
  // Вы также можете определить свой прокси, используя обычный `http_proxy` и
  // переменные `https_proxy`. Если вы используете переменные среды для конфигурации прокси
  // вы также можете определить переменную `no_proxy` как список доменов, разделенных запятыми, которые не должны быть проксированы.
  // Используйте `false`, чтобы отключить прокси, игнорируя переменные среды.
  // `auth` указывает, что для подключения к прокси-серверу следует использовать базовую аутентификацию HTTP, и предоставляет учетные данные.
  // Это установит заголовок `Proxy-Authorization`, перезаписав любой существующий
  // `Proxy-Authorization` пользовательский заголовок, который вы установили в `headers`.
  // Если прокси-сервер использует HTTPS, вы должны установить протокол `https`.
  proxy: {
    protocol: 'https',
    host: '127.0.0.1',
    port: 9000,
    auth: {
      username: 'mikeymike',
      password: 'rapunz3l'
    }
  },

  // `cancelToken` указывает токен отмены, который можно использовать для отмены запроса
  // (см. подробнее в разделе Отмена запроса ниже)
  cancelToken: new CancelToken(function (cancel) {
  }),

  // `decompress` указывает, следует ли распаковывать тело ответа
  // автоматически. Если установлено значение `true`, также удалит заголовок 'content-encoding' из объектов ответов всех распакованных ответов.
  // - Только для Node.js (XHR не может отключить декомпрессию)
  decompress: true // по умолчанию

}
```
